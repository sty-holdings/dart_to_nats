///subscription model
import 'dart:async';

import 'client.dart';
import 'message.dart';

/// A subscription to a NATS subject that receives messages as a stream.
///
/// Represents an active subscription to one or more NATS subjects, optionally as part of
/// a queue group. Messages received on the subscribed subject(s) are delivered via a 
/// broadcast [Stream].
///
/// The subscription can be configured with a [jsonDecoder] to automatically convert 
/// message payloads from JSON to typed objects.
///
/// Example:
/// ```dart
/// // Subscribe to a subject
/// final sub = await client.subscribe('foo');
/// 
/// // Listen for messages
/// sub.stream.listen((msg) {
///   print('Received: ${msg.data}');
/// });
///
/// // Unsubscribe when done
/// sub.unSub();
/// ```
///
/// See also:
/// * [Client.subscribe] - Creates subscriptions
/// * [Message] - The message type delivered by the subscription
/// * [Stream] - The stream API used to receive messages
class Subscription<T> {
  /// The unique identifier for this subscription, automatically generated by NATS
  final int sid;

  /// The subject pattern this subscription is listening to
  final String? subject;

  /// Optional queue group name for load balancing messages across subscribers
  final String? queueGroup;

  final Client _client;

  late StreamController<Message<T>> _controller;

  late Stream<Message<T>> _stream;

  /// Optional function to decode JSON message payloads into type T
  T Function(String)? jsonDecoder;

  /// Creates a new subscription to a NATS subject.
  ///
  /// Parameters:
  /// - [sid] The unique subscription ID assigned by NATS
  /// - [subject] The subject pattern to subscribe to
  /// - [_client] The NATS client instance managing this subscription
  /// - [queueGroup] Optional queue group name for load balancing
  /// - [jsonDecoder] Optional function to decode JSON payloads into type T
  ///
  /// Example:
  /// ```dart
  /// final sub = Subscription(1, 'foo', client);
  /// ```
  ///
  /// See also:
  /// * [Client.sub] - Preferred way to create subscriptions
  /// * [stream] - Access the message stream
  /// * [unSub] - Unsubscribe when done
  Subscription(this.sid, this.subject, this._client,
      {this.queueGroup, this.jsonDecoder}) {
    _controller = StreamController<Message<T>>();
    _stream = _controller.stream.asBroadcastStream();
  }

  /// Unsubscribes from this subscription to stop receiving messages.
  ///
  /// Tells the NATS server to stop sending messages for this subscription and
  /// closes the associated message stream.
  ///
  /// Example:
  /// ```dart
  /// final sub = client.sub('foo');
  /// // ... later when done
  /// sub.unSub();
  /// ```
  ///
  /// See also:
  /// * [Client.unSub] - The underlying unsubscribe implementation
  /// * [close] - Closes just the local stream without unsubscribing
  void unSub() {
    _client.unSub(this);
  }

  /// The stream of messages received from this subscription.
  Stream<Message<T>> get stream => _stream;

  /// Adds a new message to this subscription's stream.
  ///
  /// Takes a raw [Message] and converts it to a typed [Message<T>] before adding
  /// it to the subscription's stream controller. If a [jsonDecoder] is configured,
  /// it will be used to decode the message payload into type T.
  ///
  /// Parameters:
  /// - [raw] The raw message received from NATS to add to the stream
  ///
  /// The message will not be added if the stream controller is closed.
  ///
  /// Example:
  /// ```dart
  /// subscription.add(rawMessage);
  /// ```
  ///
  /// See also:
  /// * [Message] - The message type being added
  /// * [stream] - The stream receiving the messages
  /// * [jsonDecoder] - Optional function to decode message payloads
  void add(Message raw) {
    if (_controller.isClosed) return;
    _controller.sink.add(Message<T>(
      raw.subject,
      raw.sid,
      raw.byte,
      _client,
      replyTo: raw.replyTo,
      jsonDecoder: jsonDecoder,
      header: raw.header,
    ));
  }

  /// Closes this subscription's message stream.
  ///
  /// Closes the underlying stream controller, preventing any new messages from being
  /// added to the stream. This only affects the local stream - it does not unsubscribe
  /// from the NATS server. To fully unsubscribe, use [unSub] instead.
  ///
  /// Returns a [Future] that completes when the stream controller is closed.
  ///
  /// Example:
  /// ```dart
  /// final sub = client.sub('foo');
  /// // ... when done with local stream
  /// await sub.close();
  /// ```
  ///
  /// See also:
  /// * [unSub] - To fully unsubscribe from the NATS server
  /// * [stream] - The stream being closed
  Future close() async {
    await _controller.close();
  }
}
